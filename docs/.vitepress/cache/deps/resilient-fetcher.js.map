{
  "version": 3,
  "sources": ["../../../../node_modules/resilient-fetcher/src/index.ts"],
  "sourcesContent": ["export interface ResilientOptions {\n    /** Number of retry attempts (default: 3) */\n    retries?: number;\n    /** Delay between retries in ms (default: 1000) */\n    retryDelay?: number;\n    /** Request timeout in ms (default: 5000) */\n    timeout?: number;\n    /** Backoff strategy: 'fixed' | 'exponential' (default: 'fixed') */\n    backoff?: 'fixed' | 'exponential';\n    /** Custom condition to determine if request should be retried */\n    retryOn?: (error: Error | null, response: Response | null) => boolean;\n    /** Request interceptor */\n    onRequest?: (url: string, options: RequestInit) => RequestInit | Promise<RequestInit>;\n    /** Response interceptor */\n    onResponse?: (response: Response) => Response | Promise<Response>;\n    /** Error handler */\n    onError?: (error: Error) => void;\n}\n\n/**\n * Calculates delay with optional exponential backoff and jitter.\n */\nfunction calculateDelay(attempt: number, baseDelay: number, backoff: 'fixed' | 'exponential'): number {\n    if (backoff === 'exponential') {\n        const exponentialDelay = baseDelay * Math.pow(2, attempt - 1);\n        const jitter = Math.random() * 0.3 * exponentialDelay; // 0-30% jitter\n        return exponentialDelay + jitter;\n    }\n    return baseDelay;\n}\n\n/**\n * Default retry condition: retry on network errors and 5xx responses.\n */\nconst defaultRetryOn = (_error: Error | null, response: Response | null): boolean => {\n    if (!response) return true; // Network error\n    return response.status >= 500;\n};\n\n/**\n * A resilient wrapper around the native fetch API with retry and timeout capabilities.\n *\n * @example\n * const response = await resilientFetch('https://api.example.com/data');\n * \n * const response = await resilientFetch('https://api.example.com/data', {\n *   retries: 3,\n *   timeout: 10000,\n *   backoff: 'exponential'\n * });\n */\nexport async function resilientFetch(\n    url: string | URL | Request,\n    options: RequestInit & ResilientOptions = {}\n): Promise<Response> {\n    const {\n        retries = 3,\n        retryDelay = 1000,\n        timeout = 5000,\n        backoff = 'fixed',\n        retryOn = defaultRetryOn,\n        onRequest,\n        onResponse,\n        onError,\n        ...fetchOptions\n    } = options;\n\n    let attempt = 0;\n    let finalUrl = url.toString();\n    let finalOptions: RequestInit = fetchOptions;\n\n    // Apply request interceptor\n    if (onRequest) {\n        finalOptions = await onRequest(finalUrl, fetchOptions);\n    }\n\n    while (true) {\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n        try {\n            const response = await fetch(finalUrl, {\n                ...finalOptions,\n                signal: controller.signal\n            });\n\n            clearTimeout(timeoutId);\n\n            if (!response.ok) {\n                // Check if we should retry\n                if (attempt < retries && retryOn(null, response)) {\n                    attempt++;\n                    const delay = calculateDelay(attempt, retryDelay, backoff);\n                    await new Promise(resolve => setTimeout(resolve, delay));\n                    continue;\n                }\n                throw new Error(`Request failed with status ${response.status}`);\n            }\n\n            // Apply response interceptor\n            if (onResponse) {\n                return await onResponse(response);\n            }\n\n            return response;\n        } catch (error) {\n            clearTimeout(timeoutId);\n            attempt++;\n\n            const isAbort = (error as Error).name === 'AbortError';\n            const err = isAbort ? new Error('Request timed out') : error as Error;\n\n            // Call error handler\n            if (onError) {\n                onError(err);\n            }\n\n            // Check if we should retry\n            if (attempt <= retries && retryOn(err, null)) {\n                const delay = calculateDelay(attempt, retryDelay, backoff);\n                await new Promise(resolve => setTimeout(resolve, delay));\n                continue;\n            }\n\n            throw err;\n        }\n    }\n}\n\nexport default resilientFetch;\n"],
  "mappings": ";AAsBA,SAASA,EAAeC,GAAiBC,GAAmBC,GAA0C;AAClG,MAAIA,MAAY,eAAe;AAC3B,QAAMC,IAAmBF,IAAY,KAAK,IAAI,GAAGD,IAAU,CAAC,GACtDI,IAAS,KAAK,OAAO,IAAI,MAAMD;AACrC,WAAOA,IAAmBC;EAC9B;AACA,SAAOH;AACX;AAKA,IAAMI,IAAiB,CAACC,GAAsBC,MACrCA,IACEA,EAAS,UAAU,MADJ;AAgB1B,eAAsBC,EAClBC,GACAC,IAA0C,CAAC,GAC1B;AACjB,MAAM,EACF,SAAAC,IAAU,GACV,YAAAC,IAAa,KACb,SAAAC,IAAU,KACV,SAAAX,IAAU,SACV,SAAAY,IAAUT,GACV,WAAAU,GACA,YAAAC,GACA,SAAAC,GACA,GAAGC,EACP,IAAIR,GAEAV,IAAU,GACVmB,IAAWV,EAAI,SAAS,GACxBW,IAA4BF;AAOhC,OAJIH,MACAK,IAAe,MAAML,EAAUI,GAAUD,CAAY,QAG5C;AACT,QAAMG,IAAa,IAAI,mBACjBC,IAAY,WAAW,MAAMD,EAAW,MAAM,GAAGR,CAAO;AAE9D,QAAI;AACA,UAAMN,IAAW,MAAM,MAAMY,GAAU,EACnC,GAAGC,GACH,QAAQC,EAAW,OACvB,CAAC;AAID,UAFA,aAAaC,CAAS,GAElB,CAACf,EAAS,IAAI;AAEd,YAAIP,IAAUW,KAAWG,EAAQ,MAAMP,CAAQ,GAAG;AAC9CP;AACA,cAAMuB,IAAQxB,EAAeC,GAASY,GAAYV,CAAO;AACzD,gBAAM,IAAI,QAAQsB,OAAW,WAAWA,GAASD,CAAK,CAAC;AACvD;QACJ;AACA,cAAM,IAAI,MAAM,8BAA8BhB,EAAS,MAAM,EAAE;MACnE;AAGA,aAAIS,IACO,MAAMA,EAAWT,CAAQ,IAG7BA;IACX,SAASkB,GAAO;AACZ,mBAAaH,CAAS,GACtBtB;AAGA,UAAM0B,IADWD,EAAgB,SAAS,eACpB,IAAI,MAAM,mBAAmB,IAAIA;AAQvD,UALIR,KACAA,EAAQS,CAAG,GAIX1B,KAAWW,KAAWG,EAAQY,GAAK,IAAI,GAAG;AAC1C,YAAMH,IAAQxB,EAAeC,GAASY,GAAYV,CAAO;AACzD,cAAM,IAAI,QAAQsB,OAAW,WAAWA,GAASD,CAAK,CAAC;AACvD;MACJ;AAEA,YAAMG;IACV;EACJ;AACJ;AAEA,IAAOC,IAAQnB;",
  "names": ["calculateDelay", "attempt", "baseDelay", "backoff", "exponentialDelay", "jitter", "defaultRetryOn", "_error", "response", "resilientFetch", "url", "options", "retries", "retryDelay", "timeout", "retryOn", "onRequest", "onResponse", "onError", "fetchOptions", "finalUrl", "finalOptions", "controller", "timeoutId", "delay", "resolve", "error", "err", "index_default"]
}
